# ABC186
* https://atcoder.jp/contests/abc186


## C - Unlucky 7 (300点)
* keywords
  - 8進法、oct
* 解法
  - Pythonの組み込み関数[oct](https://docs.python.org/ja/3/library/functions.html#oct)を使えば、8進数表記の文字列(`0o`スタート)を簡単に取得できる


## D - Sum of difference (400点)
* keywords
  - 前処理、累積和
* 解法
  - 与えられたリストの任意の2つの数の差の絶対値を足し上げろという問題
    - よって事前に`a`をソートしておいても問題ない
  - 上記を踏まえると式を整理でき、累積和を使える形に持ち込める
  - よって2重ループを1重ループにできる


## E - Throne (500点)
* keywords
  - 拡張ユークリッドの互除法、中国剰余定理
* 解法1 (editorial)
  - `N`と`S`と`K`の最大公約数が1でない場合、それで割っておいても答えは同じ
    - 相似縮小するイメージ
  - `Kx ≡ -S (mod N)` を解けという問題になる
  - `K`のmod Nでの逆数が求まれば`x = (-S) * K^{-1} % N`と求められる
    - 逆数を求めるのに拡張ユークリッドの互除法を使える
    - `K`と`N`の最大公約数が1でない場合、解なしになる
      - `Kx + Ny = S`という一次不等式を解く問題になる
      - 今、`N`と`S`と`K`の最大公約数は1であることに注意
        - `gcd(K,N)`が`S`の約数であることはない
      - よって上記の一時不等式が解を持つ必要十分条件は `gcd(K,N)=1`
    - よって拡張ユークリッドの互除法で`K`の逆数を求め、それを`S`倍すれば良い
* 解法2
  - 何周目に余りが合うかなと考える
  - `x`周で合うとして`Nx ≡ -S (mod K)`を解けば良いことになる
  - 中国剰余定理を使う


## F - Rook on Grid (600点)
* keywords
  - BIT
* 解法
