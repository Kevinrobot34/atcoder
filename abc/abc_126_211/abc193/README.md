# ABC193
* https://atcoder.jp/contests/abc193


## C - Unexpressed (300点)
* keywords
  - 全探索
* 解法
  - `a^b`の形で表せる数は少ないことに注目して、これを全列挙する
  - editorialの様に脳死でset使えばもっと早く解けたなー


## D - Poker (400点)
* keywords
* 解法


## E - Oversleeping (500点)
* keywords
  - 中国剰余定理、拡張ユークリッドの互除法
* 解法
  - 条件をよく見て整理すると以下を満たす最小の非負整数`t`を求めればよいことが分かる
    - `X <= t mod (2X+2Y) < X+Y`
    - `P <= t mod (P + Q) < P+Q`
  - 上記式は中国剰余定理を使えそうな形
    - 具体的には連立不等式から、以下の形の連立合同式に書き換える
      - `t ≡ a (mod 2X+2Y) (X <= a < X+Y)`
      - `t ≡ b (mod P + Q) (P <= b < P+Q)`
  - 今回、`Y,Q <= 500`であったことを思い出すと全ての`a,b`に対してCRTを適用して最小となる答えを求めれば良い
  - CRTの計算（拡張ユークリッドの互除法）には`O(log min(X+Y, P+Q))`かかり、それを`YQ`回繰り返すので、`O(YQ * log min(X+Y, P+Q))`
  - 高速化について
    - その１
      - 答えの最小の非負整数`t`は`a=0`か`b=0`になる（答えは必ず駅Bに着く瞬間か起きる瞬間かのどちらかになっているはず）
      - つまり、`a=0`として`P <= b < P+Q`を全部試し、`b=0`として`X <= a < X+Y`を全部試せば十分であることがわかる
      - よって探索回数を`YQ`回から`Y+Q`回に落とすことができる
    - その２
      - 中国剰余定理の計算のうち重い部分は拡張ユークリッドの互除法のところ
      - これはよく見ると`a,b`には依存しない
      - よってこれをクエリごとに事前に計算しておくことで、中国剰余定理の部分を`O(1)`とすることができる
    - 上記2つを組み合わせることで`O(log min(X+Y, P+Q) + Y + Q)`を実現できる


## F - Zebraness (600点)
* keywords
* 解法
