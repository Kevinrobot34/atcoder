# ABC188
* https://atcoder.jp/contests/abc188
* [ABC188参加記]( https://medium.com/@kevinrobot34/abc188-cc47b27f949d )


## C - ABC Tournament (300点)
* keywords
  - シミュレーション
* 解法1
  - 愚直にシミュレーションする
* 解法2
  - editorialの通り
  - aを前後2つに分けて、それぞれの最大値を求め、2つのうち小さい方が答え


## D - Snuke Prime (400点)
* keywords
  - イベントソート、imos法、座標圧縮
* 解法1
  - ある1日に注目すると、プライムに入らない場合の支払い合計金額が、プライムプランの金額より多い場合にプライムを使いたい
  - 全ての日にちについてプライムを使わない場合の合計金額を求めたい
    - 基本的にはimos法で実現可能
    - しかし日付はMaxで`10**9`まで取りうるので座標圧縮しないといけない
  - 計算量としては座標圧縮のソートの部分が一番重く`O(NlogN)`
* 解法2(editorial)
  - 基本は解法1と同じ
  - イベントソート
    - 発想はeditorialの通り


## E - Peddler (500点)
* keywords
  - DAG、DP、トポロジカルソート、強連結成分分解、BFS
* 解法1
  - `xi < yi`の条件がつきかつ`xi -> yi`という有向辺で作られるグラフは**DAG**である
    - 更に`[1, 2, ..., n]`がそのままトポロジカル順になっている
  - よってDAG上のDPを考えることができる
    - `dp[i] = (町iまで到達できる町で買える金の最安値)`
      - 初期値：`dp[i] = INF`
      - 漸化式：`dp[j] = min(dp[j], dp[i], a[i])`
        - `i->j`の辺が存在する
      - 答え：`ans = max(a[i] - dp[i] for i in range(n) if dp[i] != INF)`
        - 町`i`で`a[i]`の値で売るとしたら、`i`までの最安値で買うのが最適
        - 上記を全ての町に対して試している
        - 最後の`dp[i] != INFを忘れずに`
  - コメント
    - 辺の条件が特に無いただのDAGの場合は自分でトポロジカルソートしないといけない
    - 一般の有向グラフの場合は[強連結成分分解]( https://mathtrain.jp/kyorenketsu )をしてから考えればいけるらしい
* 解法2
  - 最も安い金を買うことにしたとする
    - 最安値の金を買える町`x`からたどり着ける町の中で最高値の町で売るのが最適
  - 2番目に安い金を買うことにした場合
    - 同様にこの金を買える町`y`からたどり着ける町の中で最高値の町で売るのが最適
      - しかし、町`x`からたどりつける町に関しては考えなくて良い
      - なぜなら町`x`で金を買った場合の方が差額は大きいから
  - よって上記の操作を到達済みflagを管理しながらBFSすれば答えを求められる
    - ソートに`O(NlogN)`かかり、BFSに合計`O(M)`かかる
* 類題
  - [EDPC G - Longest Path]( https://atcoder.jp/contests/dp/tasks/dp_g )


## F - +1-1x2 (600点)
* keywords
  - DP、メモ化再帰、逆操作
* 解法
* memo
  - `(x, y) = (4, 14)`の答えは3
    - `x: 4 -> 8 -> 7 -> 14`
* 類題
  - [AGC044 A - Pay to Win (400点)]( https://atcoder.jp/contests/agc044/tasks/agc044_a )
    - https://sen-comp.hatenablog.com/entry/2020/05/27/015454
