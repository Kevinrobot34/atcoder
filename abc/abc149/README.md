# ABC149
* https://atcoder.jp/contests/abc149


## C - Next Prime (300点)
* 解法1
  - xから1ずつ増やして素数かどうか判定する
  - 一回の判定には`O(\sqrt{X})`かかる
* 解法2
  - エラトステネスの篩で、`2*X`くらいまで素数判定しておく
  - `O(XloglogX)`


## D - Prediction and Restriction (400点)
* 貪欲
  - K回前の制約など特になく勝てるなら、勝てる手を出しポイントをもらう
  - K回前の制約のせいで勝てない場合は、0点でK回後の邪魔にならない手を出すことにしておく


## E - Handshake (500点)
* ２つやらないといけないことがある
  - `M`回の握手の幸福度上昇の最小値を最大化する
    - 二分探索
      - 「`M`回の握手の幸福度上昇の最小値を`X`以上にできるか」つまり「`M`回の握手の幸福度上昇全てを`X`以上にできるか」を判定すれば良い
      - この判定は`O(NlogN)`でできる
        - 幸福度上昇が`X`以上であるような握手の数を数えてそれが`M`以上となるかを見れば良い
        - 左手`a[i]`を固定すると、`bisect_left(a, x-a[i])`すると幸福度上昇が`X`以上となる右手の選び方が`O(logN)`で分かる
      - 二分探索全体としては`O( NlogN * logMAX(A) )`
  - 実際にいパーティー全体の幸福度の最大値を求める
    - 幸福度上昇が`X`以上となるような握手の幸福度を足していく
    - この時累積和を使って`O(NlogN)`で済むように気をつける
    - `M`回以上余分に足してしまった分は全て`X`なはずなので、それを引いておくことも忘れずに

* 上記解法の高速化について
  - `a[i]`が小さいので、`cnt[k] = (a[i] >= kなるiの数)`を定義できる
    - これは`O(A)`で構築できる
    - editorialはここをただ「累積和」と言ってる
  - 二分探索の判定パートの`bisect_left(a, x-a[i])`を`cnt[x-a[i]]`に置き換えられるので`O(1)`になる
  - この結果全体の計算量を`O( N * logMAX(A) )`に落とせる

* 別解
  - FFT


* ちょっとだけ似てる問題 : [ARC037 C - 億マス計算]( https://atcoder.jp/contests/arc037/tasks/arc037_c )


## F - Surrounded Nodes (600点)
