# エイシング プログラミング コンテスト 2020
* https://atcoder.jp/contests/aising2020


## C - XYZ Triplets (300点)
* keyword
  - 全探索
* 解法
  - `n`ごとに`x,y,z`を全探索していると無理
  - ちょっと落ち着いて考えると、`x,y,z`に関して全探索しておけば良いことがわかる
* comment
  - 今回は使わないけど、`2n = (x+y)^2 + (y+z)^2 + (z+x)^2`


## D - Anything Goes to Zero (400点)
* keywords
  - 愚直にシミュレーション、初めだけ別途扱う
* 解法
  - 基本的にはシミュレーションをしたい
    ```python
    def count(z):
        cnt = 0
        while z:
            z = z % bin(z).count('1')
            cnt += 1
        return cnt
    ```
  - しかし、初めの数字は2進数で`N`桁あるのでそのままはできない
    - 一回操作をすれば、`2 * 10**5`未満の数になるので、その後は上記の関数ですぐシミュレーションできる
  - 一度操作した数字を計算する
    - `popcount(x)+1`と`popcount(x)-1`についていろいろな数を前計算しておくとすぐ計算できる
  - `2**n`的な数がコーナーケースであることに注意


## E - Camel Train (500点)
* keywords
  - 貪欲、スケジューリングマトロイド？
* 解法
  - 基本的には競プロフレンズさんのツイートとeditorial参照
  - とりあえず `L[i] > R[i]` として考えてみる
    - `K[i]`番目以内になるべく詰めて得したい
    - `K[i]`が小さい順に貪欲に先頭から詰めていく？
    - 先頭にいる`k`人は`K[i]`番目以内に入って`L[i]`をもらってると考えてみる
      - ある人を詰めようとしたとき、`k>=K[i]`となる場合がでてくる
        - 誰か一人に諦めて`R[j]`を使ってもらわないといけない
        - `L[j]-R[j]`が一番小さい人に`R[j]`になってもらえれば一番損失が少ない
        - これをpriority-queueで管理すれば良い
  - `R[i] > L[i]`も含む場合は...???
    - editorialにあるように、`L[i] > R[i]`なラクダは左に、`R[i] > L[i]`なラクダは右に詰めれば良いことがわかるので、独立に扱える！！
* references
  - [競プロフレンズさんのツイート]( https://twitter.com/kyopro_friends/status/1281950431237660673?s=20 )
    - > E問題は、まずラクダ全員がL[i]≧R[i]のときを考えてみるのだ！　「何もしなくてもR[i]嬉しくて、K[i]番目以内ならさらにL[i]-R[i]嬉しい」と読み替えると、K[i]が小さい方から貪欲すれば良さそうか感じがするのだ
    - > でも例えばN=3で \
      > 1 100 20 \
      > 2 100 10 \
      > 2 100 5 \
      > のとき、前から2番目までに3人は入れないから、誰か1人ガマンしてもらわないとダメなのだ。で、誰に抜けてもらうのが一番いいかというと、もちろん「追加で増える嬉しさ(L[i]-R[i])が一番小さいヤツ」なのだ
    - > だから、「今前から何番目まで埋まってるか」「追加で増える嬉しさが一番小さいのは誰か」がわかってればよくて、プライオリティーキューで解けるのだ！　L[i]<R[i]のときは今度は後ろから詰めればよくて、これはL[i]≧R[i]と干渉しないから、2組に分けてそれぞれ解けばOKなのだ！
  - [maspyさんのツイート]( https://twitter.com/maspy_stars/status/1281949260162846720 )
    - > 「左希望！」「右希望！」に分けて、それぞれの中で競争をしてもらいます。希望者の人数の合計は N 以下なので、独立にかなえた希望がそのまま全体として実現できちゃうのですね。

## F - Two Snuke (600点)
