# 東京海上日動 プログラミングコンテスト2020
* https://atcoder.jp/contests/tokiomarine2020


## C - Lamps (500点)
* keywords
  - シミュレーション、imos、累積和、計算量見積もり
* 解法
  - imos法的なことをすれば1回分の操作は`O(N)`で出来る
  - `K`回全部愚直にシミュレーションすると`O(NK)`になってしまう
  - しかし実際には`K`回も操作しなくても、`O(logN)`回操作すると全てが`N`になる
    - 初期状態が全て`0`である状態を考える
    - 両端は`1->2->4->8`と指数関数的に増加してく
    - 内側は両端以上の値になる
* comment
  - 難しかった


## D - Knapsack Queries on a tree (700点)
* keywords
  - 根付き木、二分木、ナップザック問題、半分全列挙
* 解法１
  - 高々深さが18の二分木
    - 高々`20=:2K`個のitemを使い、重さ制限`10**5=:M`のナップザック問題をとく
      - 単純には`O(M*2K)`
    - この問題を`Q<=10**5`回解かないといけない
  - 事前に根から`2**K`個分の頂点に関してナップザック問題を解いておく
    - `O(M * 2**K)`
  - クエリごとに、深さ`K`以降の頂点分については全列挙する
    - `O(Q * 2**K)`
* 解法２
  - noshiさんのやつ : https://atcoder.jp/contests/tokiomarine2020/submissions/14270733
  - > 概要: 上 2/3 下 1/3 で分割する。雑にやると二分探索の log が付くので、良い感じに消す。下の部分は葉から計算してマージしてみたいにするとクエリしたい列をマージした列が得られるので、上から計算してきた列と尺取りすると線形。
* Comments
  - PythonだとTLE厳しすぎ
    - 全列挙の部分を工夫して高速化
    - 配列の扱い
    - reversedは遅いっぽい
    - numba使うかぁ



## E - O(rand) (800点)
