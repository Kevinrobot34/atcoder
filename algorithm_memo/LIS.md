# LIS
LIS = Longest Increasing Subsequenc, 最長増加部分列

## Setup
* 数列{Ai | i = 1,2, ..., N}が与えられるのでLISの長さを求めよ
* 例
  - `A = [4, 2, 3, 1, 5]` の時、`[2,3,5]`がLISで答えは3

## 考察
DPする。発想としては「A1からAiの中から作った長さjの増加部分列が複数ある時、最終要素が小さいほど有利」なので、それを保持する配列`dp[i][j]`を用意する。\
`dp[i][j] = (A1からAiまで見て作った長さjの増加部分列の最終要素の最小値)`

* 初期化
  - 全てのjに対して`dp[0][j] = inf`
* 更新式
  - `j=1`の時か`a[i+1] > dp[i][j-1]` の時、`dp[i+1][j] = min(a[i+1], dp[i][j])`と更新
  - pythonでのざっくりイメージ
    ```python
    for i in range(1, n+1):
        for j in range(1, n+1):
            if j == 1 or a[i] > dp[i-1][j-1]:
                dp[i][j] = min(dp[i][j], a[i])
    ```

---
**実験１**

| j          | 1   | 2   | 3   | 4   | ... |
| ---------- | --- | --- | --- | --- | --- |
| `dp[1][j]` | A1  | inf | inf | inf | ... |

A2を追加することを考える。
* `A2 < A1` の時
  | j          | 1   | 2   | 3   | 4   | ... |
  | ---------- | --- | --- | --- | --- | --- |
  | `dp[2][j]` | A2  | inf | inf | inf | ... |

* `A1 < A2` の時
  | j          | 1   | 2   | 3   | 4   | ... |
  | ---------- | --- | --- | --- | --- | --- |
  | `dp[2][j]` | A1  | A2  | inf | inf | ... |

dpは単調増加なまま

---

**実験２**

| j          | 1   | 2   | 3   | 4   | ... |
| ---------- | --- | --- | --- | --- | --- |
| `dp[i][j]` | a   | b   | inf | inf | ... |

(ただし a < b)
という状況を考える。

cを追加することを考える。
* `c <= a < b` の時
  | j            | 1   | 2   | 3   | 4   | ... |
  | ------------ | --- | --- | --- | --- | --- |
  | `dp[i+1][j]` | c   | b   | inf | inf | ... |


* `a < c <= b` の時
  | j            | 1   | 2   | 3   | 4   | ... |
  | ------------ | --- | --- | --- | --- | --- |
  | `dp[i+1][j]` | a   | c   | inf | inf | ... |

* `a < b < c` の時
  | j            | 1   | 2   | 3   | 4   | ... |
  | ------------ | --- | --- | --- | --- | --- |
  | `dp[i+1][j]` | a   | b   | c   | inf | ... |

このようにどの場合もdpは単調増加なまま

---

以上の実験から、結局
* `dp[j] = (長さjの増加部分列の最終要素の最小値)` を用意
* 初めはすべての要素をinfで初期化しておく
* 更新について
  - `j=1`でかつ`a[i] < dp[0]`の時、`dp[0] = a[i]`
  - `j>1`でかつ`dp[j-1] < a[i] <= dp[j]`の時、`dp[j] = a[i]`
* dp[j]は更新を経ても単調増加なまま
* dp[j]は単調増加なので、更新はただ一つのjに対してのみ起こる
  - lower_bound(bisect_left)を用いて更新される場所を二分探索すれば良い

こうして蟻本に載っているO(NlogN)のアルゴリズムができた。


## Reference
* https://qiita.com/python_walker/items/d1e2be789f6e7a0851e5
* https://www.slideshare.net/chokudai/abc006
